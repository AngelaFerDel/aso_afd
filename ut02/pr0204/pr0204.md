#### [Volver a Unidad 2](../index.md)

------------

# Unidad 2 - Práctica 4: Gestión de procesos en Linux

## Ejercicio 1 - Exploración básica de procesos.

### Apartado 1.

Usando el comando `ps` en mi caso solo muestra 2 procesos, para poder listar 3 habría que poner otro proceso a ejecutarse.
Los PID de los 2 únicos procesos que me salen son: 1222 y 1282, correspondientes a `bash`y a `ps`.

### Apartado 2.

Empleamos el comando `ps aux` desde la terminal, en la lista de todos los procesos podemos observar por ejemplo procesos hechos por el usuario root, su PID es el siguiente: 896, que corresponde a login --angela

### Apartado 3.

#### ¿Qué diferencia hay entre el comando ps y ps aux?

`ps` es el comando base, sin ningún tipo de modificador, solo permite ver los procesos que ese estén ejecutando en la temrinal en la que estemos trabajando, mientras que `ps aux`  corresponde a listar todos los procesos (`ps a`), mosttrar los propietarios de los procesos (`ps u`) y mostrar los procesos que no tengan una terminal asignada (`ps x`)

#### Cuando decimos que un proceso pertenece a un usuario, ¿qué implicaciones tiene? Es decir, ¿en qué afecta eso al proceso?

El usuario propietario del proceso implica que ese usuario es el que ha ejecutado dicho proceso.
Además, ese proceso tendrá los permisos del propietario, es decir, un proceso con un usuario normal no podrá eliminar directorios del directorio raíz por mucho que queramos ejecutar el proceso. Ese proceso deberá hacerlo el usuario root.

## Ejercicio 2 - Monitorización de procesos en tiempo real.

### Apartado 1.

Usando el comando `top` en nuestra terminal nos muestra el listado de procesos activos pero de forma dinámica.
Qué proceso ocupa más porcentaje de la CPU cambia cad aaproximadamente 5 segundos.
Así que en el momento actual es este:

![Captura apartado 1](pr0204_Capturas/pr0204_1.png)
Su PID es: **61**

### Apartado 2.

Si mientras se está ejecutando `top` pulsamos la tecla `M`en nuestro teclado, además de ordenarse por porcentaje de CPU, se ordenará por porcentaje de memoria usada. En este caso, el proceso qeu ocupa más memoria es el siguiente:

![Captura apartado 1](pr0204_Capturas/pr0204_2.png)
Su nombre es: **systemd**

### Apartado 3.
#### ¿Qué columnas de información se muestran en top y cuál es su significado?

Las columns que muestran el comando top son las siguientes:

- **PID**: Identificador del proceso.
- **USER**: Usuario propietario/que ejecuta el proceso.
- **PR**: Prioridad con la que se ejecuta el proceso en el kernel.
- **NI**: Prioridad del proceso.
- **VIRT**: Cantidad de memoria virtual utilizada para este proceso. 
- **RES**: Cantidad de memoria residente ocupada por este proceso.
- **SHR**: Cantidad de memoria compartida empleada para el proceso.
- **S**: *"State"*, el estado del proceso
- **%CPU**: Porcentaje de CPU que ocupa el proceso.
- **%MEM**: Porcentaje de memoria que ocupa el proceso.
- **TIME+**: Tiempo que lleva ejecutandose el proceso.
- **COMMAND**: Nombre del proceso.

#### ¿Cómo puedes cambiar el intervalo de actualización de top?

Para cambiar la frecuencia de muestreo deol comando `top`, mientras este se esté ejecutando pulsaremos la letra `d`en nuestro teclado. Ahora deberemos introducir el tiempo de muestreo en segundos y le daremos a Enter para aplicar los cambios.

![Captura apartado 3](pr0204_Capturas/pr0204_3.png)

## Ejercicio 3 - Detener y reanudar procesos.

### Apartado 1.

Ejecutamops el comando `sleep 300 &`, con esto crearemos un proceso de 300 segundos.

![Captura apartado 4](pr0204_Capturas/pr0204_4.png)

### Apartado 2.

Si ejecutamos el comando `jobs`, nos mostrará todos los procesos en segundo plano, en este caso, nos aparece el proceso que creamos antes, para que nos muestre el id deberemos añadirle le modificafor `-l`, de forma uqe para que nos muestre su ID deberemos ejecutar `jobs -l`
El ID del proceso es: **1963**

### Apartado 3.

Para detener el proceso usaremos el comando `kill` añadiendo como modificador el númeor de la señal que queremos enviarle.
En este caso haremos `kill -n 20 1963`

### Apartado 4.

Para ahora reanudar el proceso, enviaremos la señal 18 con el comando kill usanod el comando:
`kill -n 18 1963`

### Apartado 4.
#### ¿Qué efecto tiene la señal SIGSTOP sobre un proceso?

Detiene temporalmente el proceso, como si hubiésemos pulsado Ctrl+Z mientras ejecutamos un proceso.
Deja el proceso preparado para poder continuarlo en cualquier momento con la señal SIGCONT(18).

#### ¿Cómo puedo verificar si un proceso está detenido o en ejecución?

Tanto en el ocmando `ps` como en `top` existe una columna que hace referencia al estado del proceso, que está representado con una letra. Esto indica si está:
- Detenido -> **S**
- En ejecución -> **R**
- Dormido -> **D**
- Haciendo trazas o parado -> **T**
- Zombie -> **Z**

## Ejercicio 4 - Terminar procesos.

### Apartado 1.

De la misma forma que en el ejercicio anterior, creamos un proceos usando el comando `sleep 600 &`

### Apartado 2.

Usamos el comando `ps aux` para observar el PID del proceso.
Para que la búsqeda sea más fácil, usaremos `ps aux | egrep "sleep 600"`
En el resultado que nos sale veremos nuestro proceso con su PID, qu es el **2000**

### Apartado 3.

Mataremos el proceso usando el comando `kill` junto con la señal SIGKILL que es el número 9.
De forma que si ejecutamos:  `kill -n 9 2000` mataremos el proceso

### Apartado 4.
#### ¿Qué diferencia hay entre las señales SIGTERM y SIGKILL?

SIGTERM envía una petición a los procesos para que finalicen de forma ordenada. 
Mientras que SIGKILL manda la señal que fuerza a que finalicen inmediatamente.

#### ¿Por qué es preferible utilizar SIGTERM antes que SIGKILL para terminar un proceso?

Porque es posible que al mandar finalizar a los procesos de forma abrupta ocurran errores por procesos que se queden a medias. Si se emplea SIGNTERM, ese problema se soluciona pues antes de finalizar terminan de hacer su función y se cierran ordenadamente.

## Ejercicio 5 - Prioridades de procesos.

### Apartado 1.

Emplearemos el comando `nice -n 10 sleep 300 &` para crear un proceso con prioridad baja.

### Apartado 2.

Emplearemos el comando `ps -l` para ver la propridad del proceso.
Miraremos el valor de NI que en este caso es **10**.

### Apartado 3.

Cambiaremos la prioridad del proceso usando el comando `renice` para que sea 5 de la siguietne manera:
`renice <valor> <PID>`

![Captura apartado 5](pr0204_Capturas/pr0204_5.png)

Comprobamos que hemos realizado correctamente los cambios con un `ps -l`

![Captura apartado 6](pr0204_Capturas/pr0204_6.png)

### Apartado 4.

#### ¿Para qué sirve el comando `nice`?

Nice es el comadno que sirve para crear un proceso con un valor de prioridad concreto.

#### ¿Qué rango de valores puede tomar la prioridad (nice value) de un proceso y qué significa cada extremo?

Los valores deprioridad en Linux van desde -20 , que es la prioridad más alta hasta 19 que es la prioridad nás baja.

#### ¿Qué ocurre si intentas cambiar la prioridad de un proceso que no te pertenece?

Da automáticamente error por falta de permisos Si quieres cambniar la prioridad de un proceso que no ha creado tu  usuario deberás cambiarlo desde el root empleando sudo.


## Ejercicio 6 - Procesos en primer y segundo plano.

### Apartado 1.

Ejecutamos el comando `sleep 200` y después detenmos el proceso pulsando Ctrl+ Z.


### Apartado 2.

Usamos el comanodo `bg` qeue significa literalmente *background*. Este comando muestra todos los procesos detenidos que están en segundo plano. Si lo ejecutamos veremos el comando **sleep 200** que ejecutamos antes.

![Captura apartado 7](pr0204_Capturas/pr0204_7.png)

### Apartado 3.



### Apartado 4.



## Ejercicio 7 - Uso de `pstree` y `htop`.

### Apartado 1.



### Apartado 2.



### Apartado 3.



### Apartado 4.



## Ejercicio 8 - Matar procesos de manera forzosa.

### Apartado 1.



### Apartado 2.



### Apartado 3.



### Apartado 4.



------------

#### [Volver a Unidad 2](../index.md)